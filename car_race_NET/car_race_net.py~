import json
import numpy as np

# el archivo data.json tiene almacenadas las pociciones de los oponentes en la grilla con cientos de casos de ejemplo
data_in = json.load(open('data_final.json'))

grid = np.zeros(shape=(6, 5), dtype=float, order='F')
out = np.zeros(shape=(5, 1), dtype=float, order='F')

data = []

# cargo en la lista data todos los datos del archivo data.json
for d in data_in:
    grid = np.zeros(shape=(6, 5), dtype=float, order='F')
    out = np.zeros(shape=(5, 1), dtype=float, order='F')
    for g in d:
        if (g['y'] >= 0 and g['y'] < 24):
            grid[int(g['y']/4)][int(g['x']/3)] = 1
    data.append((grid, out))

# posiciono al jugador(.5) de forma aleatoria sobre la fila 5 de la grilla
for d in data:
    d[0][5][int(np.random.rand()*5)] = .5
    #d[0][5][1] = .5#

# busco en cada grilla si tiene solucion y calculo la salida esperada para dicha entrada(grilla)
data_path = []

player_pos = -1
l = []
l_final = []
data_aux = []

def calculate_path(p, yy, xx, r, score):
    global l
    global l_final
    global final_score
    # global aux_dir
    # global final_dir
    if p[yy][xx] != 0:
        if yy == 0:
            score += p[yy][xx]
            if score < final_score:
                final_score = score
                # final_dir =  aux_dir
                l_final = []
                for ll in l:
                    l_final.append(ll)
        else:
            #buscar a izquierda
            if xx < 4 and p[yy][xx + 1] < 0 and r != 1:
                # if yy == 5:
                #     aux_dir = 0
                l.append([('y', yy), ('xx', xx), ('peso', p[yy][xx])])
                calculate_path(p, yy, xx + 1, 0, score + p[yy][xx])
                del l[-1]
            #buscar a derecha
            if xx > 0 and p[yy][xx - 1] < 0 and r != 0:
                # if yy == 5:
                #     aux_dir = 1
                l.append([('y', yy), ('xx', xx), ('peso', p[yy][xx])])
                calculate_path(p, yy, xx - 1, 1, score + p[yy][xx])
                del l[-1]
            #buscar arriba
            if yy > 0 and p[yy - 1][xx] < 0:
                # if yy == 5:
                #     aux_dir = .5
                l.append([('y', yy), ('xx', xx), ('peso', p[yy][xx])])
                calculate_path(p, yy - 1, xx, .5, score + p[yy][xx])
                del l[-1]


for d in data:
# t=11#
# if t == 11:#
    # d = data[t]#
    _in = d[0]
    _out = d[1]
    path = np.zeros(shape=(6, 5), dtype=float, order='F')
    np.copyto(path, _in)
    for y in range(6):
        for x in range(5):
            if _in[y][x] == 0 or _in[y][x] == .5:
                if _in[y][x] == .5:
                    player_pos = x
                if x == 0:
                    if y == 0:
                        path[y][x] = _in[y][x + 1] - 2
                    else:
                        path[y][x] = _in[y - 1][x] + _in[y][x + 1] - 2
                elif x == 4:
                    if y == 0:
                        path[y][x] = _in[y][x - 1] - 2
                    else:
                        path[y][x] = _in[y - 1][x] + _in[y][x - 1] - 2
                else:
                    if y == 0:
                        path[y][x] = _in[y][x - 1] + _in[y][x + 1] - 3
                    else:
                        path[y][x] = _in[y - 1][x] + _in[y][x - 1] + _in[y][x + 1] - 3
    final_score = 0
    # final_dir = -1
    # aux_dir = -1
    calculate_path(path, 5, player_pos, .5, 0)
    h = 0
    # busco el lugar por el que pasa de las linea 5 a la 4
    while l_final[h][0][1] != 4:
        h += 1
        try:
            k = l_final[h][1][1]
        except:
            print (h)
            print (path)
            print (l_final)
            exit()
    _out[k][0] = 1

    # if l_final[0][0][1] == l_final[1][0][1]:
    #     if l_final[0][1][1] < l_final[1][1][1]:
    #         _out[0] = 1
    #     else:
    #         _out[0] = 0
    # else:
    #     _out[0] = .5
    # if final_dir == -1:
        # final_dir = .5
    # _out[0] = final_dir
    if final_score != 0:
        data_aux.append(d)
        data_path.append([('path', path),('final_score', final_score)])
data = data_aux

# verificar que no haya casos erroneos (encierror y score en cero)
for x in range(len(data)):
    for k in range(5):
        if data[x][0][5][k] == .5:
            if k == 0 or data[x][0][5][k - 1] == 1:
                if k == 4 or data[x][0][5][k + 1] == 1:
                    if data[x][0][4][k] == 1:
                        del data[x]
                        del data_path[x]
    if len(data)-1 == x:
        break

print ("ok.. no hay encierros")
for x in range(len(data)):
    if data_path[x][1][1] == 0:
        del data[x]
        del data_path[x]
    if len(data)-1 == x:
        break

for x in range(len(data)):
    if data_path[x][1][1] == 0:
        print (x)
        print (data[x])
        print (data_path[x])
        print ("scores en cero")
        exit()

print ("ok.. no hay scores en cero")


print (len(data))
for x in range(2):
    t = np.random.randint(0, len(data))
# if t == 11:#
#     d = data[t]#
    print (t)
    print (data[t])
    print (data_path[t])
    # print (data_path[0]#
    # print (l_final#

while 0 == 0:
    q = int(input("ingrese un indice:\n"))
    if q == -1:
        exit()
    if q == -2:
        break
    if q < len(data):
        print (q)
        print (data[q])
        print (data_path[q])
x_train = np.empty(shape=(10000, 30), dtype=float)
y_train = np.empty(shape=(10000, 5), dtype=float)
x_test = np.empty(shape=(1000, 30), dtype=float)
y_test = np.empty(shape=(1000, 5), dtype=float)
if len(data) >= 11000:
    for x in range(10000):
        for i in range(6):
            for j in range(5):
                x_train[x][i*5+j] = data[x][0][i][j]
                if i == 0:
                    y_train[x][j] = data[x][1][j]
    for x in range(10000, 11000):
        for i in range(6):
            for j in range(5):
                x_test[x-10000][i*5+j] = data[x][0][i][j]
                if i == 0:
                    y_test[x-10000][j] = data[x][1][j]
    
    from keras.models import Sequential
    from keras.layers import Dense, Activation
    model = Sequential()
    model.add(Dense(15, activation='relu', input_dim=30))
    model.add(Dense(10, activation='tanh'))
    model.add(Dense(5, activation='softmax'))
    model.compile(loss='categorical_crossentropy',
                  optimizer='sgd',
                  metrics=['accuracy'])
    model.fit(x_train, y_train, epochs=30, batch_size=5)
    loss_and_acc = model.evaluate(x_test, y_test, batch_size=5)
    print ("Evaluated test_data results --> loss: {0:.4f} - acc: {1:.4f}".format(loss_and_acc[0], loss_and_acc[1]))
    classes = model.predict(x_test, batch_size=128)
